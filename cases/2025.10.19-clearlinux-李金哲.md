# ClearLinux初探
## 综述
ClearLinux由Intel负责维护升级，其备以下特点
- 针对Intel指令集，对软件栈各个层级进行了性能优化，确保业务场景的高性能。
- 为了便于用户使用高性能的软件栈，CL使用直接面向业务场景设计的包管理方式bundle，并且通过独特的mix和差分升级提高升级效率。用户可以通过安装bundle直接完成业务场景部署。
- 同时，CL采取了其称为“无状态”（stateless）的系统管理，通过为用户提供标准config，并支持用户轻松实现覆写/重置配置。
## 性能优化
CL最大的卖点是针对Intel架构（IA）的较激进的优化。CL通过三个手段实现优化：
1. **编译时优化**：CL对所有软件包的构建默认开启了**大量性能优化flags**，并且以`Intel Westmere架构`为基线（该架构开始引入了硬件加速AES计算指令）抛弃了部分兼容性；并针对`Haswell架构`默认开启性能调优（一方面放弃了兼容性；另一方面对编译器和硬件拓展都有要求，是否有效`取决于后续架构配置集合中是否对已有拓展有所优化`。对照可能类似以RV64GC为基线并对RVA23开启性能调优）。
2. **运行时优化**：
   1. 运行时linker会根据当前机器CPU支持的特性，动态挑选`针对特性优化的运行时库`进行链接（典型的例子是基于向量计算拓展优化的矩阵计算库，在IA上是`AVX`，在RISC-V上则是`V拓展`）。
   2. Intel针对`性能热点软件`制作了基于IA的优化patch（如针对openssl在RISC-V上制作基于V拓展优化的patch）。

同时，CL为了进一步优化性能，为主要的生态伙伴（Azure，Google等）以及常用开发环境（裸机/QEMU/Hyper-V等）专门制作镜像和优化patch（推动合入Linux上游）。以及为了拓展CL生态到嵌入式场景，除了裸机部署，CL对ACRN（嵌入式hypervisor）进行了适配和优化以作为ACRN的管理VM运行。
## 发行版管理
ClearLinux的发行版版本与其它发行版不同，采取**滚动更新**模式，没有固定的发行时间，一周可以发布9个release版本。ClearLinux通常以自身作为构建服务器，每个发行版生命周期主要包括两个部分：
- **content workflow**: 该部分主要负责两个任务
  1. 检查上游软件仓是否有新版本发布，并通过内容提供者（如Koji）等生成RPM包。
  2. **Watcher Pipeline**负责检查CL和RPM提供者，判断是否需要发布新版本。
- **release workflow**:
  1. 收集生成的RPM包并提供给**mixer**使用（用于生成bundle）。
  2. **Release Pipeline**负责整合CL上游和CL衍生版内容，并发布新版本。

整个流程的核心软件包是`clr-distro-factory`，同时CL会定期**扫描CVE信息并制作补丁**，以确保CL保持更新。

ClearLinux采用`Bundle`，与其它发行版的pkgs grounp类似，bundle通常是**多个packages的集合**，但是bundle天然是为了管理一个业务场景所需的软件包设计的，每个bundle已经包含所需的所有依赖（即安装bundle时无需根据依赖再去获取其它软件包，**这样的好处是可以完全在构建时建立所有依赖，而不是在安装时获取，有助于版本管理**）

- （按照CL的说法，pkgs group的管理是水平的，松散软件包的集合，而bundle是垂直的，可以以良好的分层抽象管理业务场景所需的软件包，**有点类似openEuler当前使用的oeDeploy**）。

对应的，为了便于用户使用bundle，CL提供的关键软件包包括`swupd`和`mixer`，前者负责从服务器获取bundle元数据和文件，后者实现基于`RPM包`和`Bundle definitions`（类似RPM spec）制作`更新制品`（update artifact）。其工作模式在[Update章节详细说明](#update)。


## Update
类似其它发行版，bundle版本会与OS版本关联，即bundle版本由`OS版本`+`bundle版本`组成。升级OS时会对当前安装的所有bundle同时进行升级。

为了简化对bundle的管理，每个bundle分为数据和元数据部分。如[前文所说](#发行版管理)，**bundle由`mixer`根据`原始RPM包`和`bundle definition`制作得到**。CL称mixer为`Update Generator`，而生成的bundle升级文件则称为`Update artifacts`。update artifacts和bundle都由两部分组成，由manifest构成的元数据和pack记录的数据部分。
- **元数据**：描述了当前bundle版本，所有文件信息和hash值等，以`Manifest`为单位进行管理，并且由`Manifest of Manifests(MoM)`管理所有的manifest。MoM与bundle的manifest类似，记录了所有manifest的bundle信息和hash值等。
    
    为了确保软件可信，在update时，OS在确保MoM可信的前提下，用MoM中记录的hash值对manifest进行校验，确保manifest可信；然后由manifest中记录的hash值对bundle中所有的文件进行校验，完成可信软件包的验证。
- **数据**：描述了当前bundle实际包含的文件，仍然由mixer生成。为了优化CL升级和分发的性能，CL支持对bundle`文件级差分更新`。mixer可以针对bundle version X到version Y的差异生成`delta pack`，记录的普通文件/二进制文件间的差异；对于新引入软件包（version 0），则提供完整的文件。

    同时，为了避免差分升级失败，CL同样提供了完整的文件（fullfiles pack）作为fallback选项。

由mixer生成的内容最终由`swupd`使用，使用swupd的系统升级总体分为四个部分：1.获取MoM以及manifests并进行校验。 2.根据manifests获取packs，应用补丁并暂存文件。 3.根据manifests校验暂存文件。 4.使用暂存文件覆盖更新前文件
    
- （除步骤4均为原子操作，允许中断和回退，步骤4中断可能导致严重问题，即包被标记为更新但是文件本身尚未被覆盖）

CL同样支持用户通过mixer实现自定义bundle，包括通过有选择的使用CL上游bundle内容，与用户自定义的bundle进行结合，发布自己的CL衍生版本；以及使用mixer在本地制作local artifacts，与CL上游bundle进行merge，**在接收上游更新的同时保持用户侧载内容完整性。**

（**CL的面向业务场景的包管理方式和文件级别的差分升级方式，与apt/yum相比软件包管理灵活性较低，但是一方面可以简化用户部署和更新业务软件的复杂度，另一方面可以更有效的为用户提供优化后的软件栈，避免用户优化部分组件导致的兼容性问题，和降低软件栈整体优化并部署的难度。**）